#!/bin/sh

_exists(){ type $1 2>&1 | grep -iq function; }
_is_app(){ which $1 >/dev/null 2>&1; }
_ok(){ printf "[\e[32m$@\e[0m]" >&2; }
_done(){ printf ' [\e[32mdone\e[0m]\n'; }
_no(){ printf "[\e[32m$@\e[0m]" >&2; }
_fail(){ printf ' [\e[31mfail\e[0m]\n'; }

_version_increment(){
  local v=$(printf "%d" $(cat $BUILD/version 2>/dev/null || printf 0))
  printf "0x%x" "$(( $v + 1 ))" >$BUILD/version
  _version; }

_git_source(){ local name="$1" url="$2"; shift 2
  [ -d "$SOURCES/$name" ] || git clone --depth=1 "$url" "$SOURCES/$name" "$@"; }

# exec

_exec_destdir(){ _arch_hook __exec "$DESTDIR" "$1"; }
_exec_debroot(){ _arch_hook __exec "$DEBIAN"  "$1"; }

# qemu

__qemu_default(){ kvm         \
  -cpu host -smp 2 -no-reboot \
  "$@"; }

_run_kvm(){ # (: test kernel / ramdisk / squashfs-image :)
  local x='-nographic'
  local a='console=ttyS0'
  [ ":$1:" = ":-x:" ] && { x="-vga qxl"; a=; }
  # (: create storage :)
  test -f $SOURCES/storage.img || {
    echo creating storage...
    truncate -s 1000M $SOURCES/storage.img
    mkfs.ext4 $SOURCES/storage.img; }
  echo booting...
  # -usb -device usb-host,hostbus=1,hostaddr=5 \
  _arch_hook __qemu $x       \
   -m 512                    \
   -kernel $KERNEL_EMU       \
   -initrd $RAMFS.gz         \
   -hda $SOURCES/gearos.img  \
   -hdb $SOURCES/storage.img \
   -append "quiet root=/dev/ram0 rootfstype=tmpfs rw init=/etc/rc $a"; }

# debian related

_debroot_compile(){
  local src="$1" dst="$2" name=$(basename $1) dstname=$(basename $2)
  [ -x $dst ] || {
    cp $src $DEBIAN/tmp/
    _exec_debroot "cd /tmp; diet gcc -static -o $dstname $name"
    cp $DEBIAN/tmp/$dstname $dst; chmod a+x $dst; }; }

_deburl(){
  local URL="$1"; shift
  awk -vURL="$URL" -va="$*" '
BEGIN{ wget = "wget -O- " URL " 2>/dev/null"
  while( (wget|getline) > 0){
    if( 0 == index($0,"deb") ) continue
    gsub(/.*a href="/,""); gsub(/".*/,"")
    split(a,h," "); l = 1 + length(h); c = 1
    for(i=1;i<l;i++) if( 0 == index($0,h[i]) ) c = 0
    if(c) {
      if ( 1 == index($0,"http") ) print $0
      else print URL $0
 close(wget);exit(0)}
}close(wget);exit(1)}'; }

_depend_http(){
  [ -n "$2" ] &&
  { local url="$2" name="$1"; } ||
  { local url="$1" name=$(basename "$1"); }
  [ -f "$SOURCES/$name" ] ||
  $(which wget) -O "$SOURCES/$name" "$url"; }

_depend_deb(){
  if [ -z "$2" ]
  then local url="$1" name=$(basename "$1")
  else local name="$1" url="$2"
  fi
  [ -d $SOURCES/$name ] || {
    mkdir $SOURCES/$name
    echo DOWNLOADING $name
    $(which wget) -O- "$url" | dpkg-deb -x /dev/stdin $SOURCES/$name; }; }

_depend_deb_from(){ local name="$1" url="$2"; shift 2
  [ -d "$SOURCES/$name" ] && return 0
  _depend_deb "$name" "$(_deburl "$url" "$@")"; }

_debroot(){
  _arch_hook debroot # else setup $DEBRROT ($DESTARCH debian chroot)
  [ -d $DEBIAN ] && return 0
  SCRIPT=testing
  qemu-debootstrap --variant=minbase --no-check-gpg --arch=$DESTARCH_DEBIAN $SCRIPT $DEBIAN $DEBIAN_REPO
  echo 'Acquire::Languages "none";' > $DEBIAN/etc/apt/apt.conf.d/99translations
  _exec_debroot "apt-get update";
  # _depend_apt tcc  build-essential
  _depend_apt gcc  build-essential
  _depend_apt diet dietlibc-dev; }
debroot_default(){ :; }

_depend_apt_host(){
  local bin=$1 lib=$2
  test -z "$bin" && return 1
  test -z "$lib" && lib=$1
  which $bin >/dev/null 2>&1 || sudo apt-get install -y --no-install-recommends $lib; }

_depend_apt_lib(){
  local i= need=; for i in $@; do [ -n "$(_exec_debroot "apt-cache policy $i| grep -i Installed:..none.")" ] && need="$need $i"; done
  [ -n "$need" ] && _exec_debroot "apt-get install -y --no-install-recommends $need"; }

_depend_apt(){
  local bin=$1 lib=$2
  test -z "$bin" && return 1
  test -z "$lib" && lib=$1
  bin=$(_exec_debroot "which $bin") 2>/dev/null
  [ -n "$bin" ] || _exec_debroot "apt-get install -y --no-install-recommends $lib"; }

_arch_file_or_depend(){
  local file="$1" package="$2"; [ -n "$2" ] || package="$1"
  [ -z "$(_arch_file $file)" ] && _depend_apt $file $package; }

_steal_kmod(){  local dest="$1"; shift
  local src="$SOURCES/linux" dir=
  local mods="$src/lib/modules/$KERNEL_VERSION"
  [ -f "$mods/modules.dep.bin" ] || {
    printf "\e[1;43;30m depmod -b $src $KERNEL_VERSION \e[0m" >&2
    $(which depmod) -b "$src"     $KERNEL_VERSION; }
  [ -f "$mods/modules.dep" ] || {
    printf "\e[1;43;30m busybox depmod -b $src $KERNEL_VERSION \e[0m" >&2
    $SOURCES/busybox depmod -b "$src" $KERNEL_VERSION; }
  [ -d $mods ] || { printf "\e[1;42;30m $mods \e[0m" >&2; return 1; }
  $(which modprobe) -d "$src" -S "$KERNEL_VERSION" -D "$1" |
    sed "/^builtin /d;s|insmod $src||g" |
  while read file
  do dir="$dest/$(dirname $file)"
     [ -d "$dir" ]        || mkdir -p      "$dir"
     [ -f "$dest/$file" ] || cp $src/$file "$dir"
  done; }

_steal_kmods(){ local mod= dest="$1"; shift
  for mod in "$@"
  do _steal_kmod "$dest" "$mod"
  done; }

_steal_app(){ (
  for a in $@;do
    test -f $DEBIAN/$a   || app=$(_exec_debroot "which $a")
    test -f $DEBIAN/$app || { printf "[\e[31m$a\e[0m]" >&2; return 1; }
    printf "[\e[33mapp\e[0m:\e[35m$(basename $a)\e[0m]" >&2
    rm -f $DESTDIR/bin/$a
    cp $DEBIAN/$app $DESTDIR/bin/
    _steal_libs $app
  done; ); }

_steal_libs(){ (
  local app=$1
  [ -f "$app" ] || app=$(_exec_debroot "which $app")
  printf '\e[32m+\e[0m'
  for dep in $(_exec_debroot "ldd $app"|awk '{print $1}'); do
    _steal_lib $dep
  done; ); }

_steal_lib(){ (
  local LIB= dep=$(basename "$1")
  local LIBS="/lib /usr/lib /lib/$DESTARCH_MULTI /usr/lib/$DESTARCH_MULTI $(cat $DEBIAN/etc/ld.so.conf.d/* | grep -v '^#')"
  [ -z "$dep" -o "$dep" = 'not' -o -f $DESTDIR/$dep* ] && return 0
  for lib in $LIBS; do
    [ -e $DEBIAN$lib/$dep ] && { LIB=$DEBIAN$lib/$dep; break; }
    LIB=$(find $DEBIAN$lib | grep -I $dep | head -n1)
    [ -n "$LIB" ] && break
  done
  if   [ -z "$LIB" ]
  then [ "$dep" = "linux-vdso.so.1" ] || {
    printf "[\e[31m$1:$dep\e[0m]"; }
    return 1
  elif [ -f $DESTDIR/lib/$(basename $LIB) ]; then printf '\e[33m=\e[0m' >&2
  else { printf '\e[32m[%s]\e[0m' $dep >&2; cp $LIB $DESTDIR/lib/; }; fi; )
  true; }

_arch_file_or_steal(){
  local file=$(_arch_file $1)
  if [ -n "$file" ]
    then cp $file $2/$1
    else _steal_app $1
  fi; }

_select_device(){
  _lsblk(){ lsblk -pl | awk '
    BEGIN{getline;df="df"
      while( ( df | getline ) > 0 ){
        mounted[$1] = 1 }
        close(df)}
    (!mounted[$1]){printf "%4s %6s %s\n", $6, $4, $1}'; }
    _splash select DEVICE 'Select Target' "$(_lsblk)"
  export DEVICE=$(echo $DEVICE | awk '{print $3}');
  DEVICE=
  [ -w "$DEVICE" ] || { DEVICE=; return 1; };
  _splash yesno NULL "Really erase [$DEVICE]" || {
    DEVICE=; return 1; }; }
