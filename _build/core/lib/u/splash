#!/bin/sh

_usplash(){
_stty(){ stty "$@" 2>/dev/null; }
_uwk(){ $BUSYBOX awk -vBUSYBOX="$BUSYBOX" -vUSPLASH="$USPLASH" "$@" -f $UGEAR/splash.awk; }
_usplash_render(){ _uwk -vCOLS=$COLS -vROWS=$ROWS -vCMD=render; }
_usplash_send(){ $BUSYBOX nc local:$USPLASH/render >/dev/null 2>&1; }
_usplash_ping(){ test "PING" = "$(echo PING|_usplash_send)"; }
_usplash_fini(){ echo EXIT | _usplash_send; }
_usplash_init(){
  if [ -d $USPLASH -a -e $USPLASH/render ]; then
    if [ "$1" = "force" ]; then
      if _usplash_ping; then return 0
      else
        $BUSYBOX fuser -k -KILL $USPLASH/render
        rm -f $USPLASH/render; fi
    else return 0; fi
  else
    mkdir -p $USPLASH
    detect_tty_size
    _usplash_render &
  fi; true; }

_usplash_passwd(){ _usplash_init; local tty=$(_stty -g)
  printf "\e[33m %s \e[0m\n [ typing is hidden ] \nRENDER\n" "$2" | _usplash_send
  _stty cooked; read -s "$1"; export "$1"; _stty $tty; }

__menu__(){ _uwk -vHEADLINE="$headline" -vUPDATE="$update" -vCMD=menu; }
_usplash_menu(){ _usplash_init; local headline="$1" tty=$(_stty -g) update=0
  case "$1" in
    item) shift; [ -z "$1" ] && return 1
      local menu="$1" menupath="$USPLASH/$1"; shift
      if [ ":--remove:" = ":$1:" ]
      then rm -rf "$menupath"*; shift 1;
      elif [ -n "$1" -a -n "$2" ]
      then
        echo "$1" > "$menupath.menu";
        echo "$2" > "$menupath.action";
        shift 2
      else echo "ERROR Not enough arguments for $@"; return 1
      fi; update=1;;
    context) shift; [ -z "$1" ] && return 1
      local menu="$1" parpath="$USPLASH/$1"
      if [ ":--remove:" = ":$1:" ]
      then rm -rf "$menupath"*; shift
      else local menupath="$parpath.context"; shift
        mkdir -p $menupath
        if [ ! -f "$menupath/_default.title" ]
        then
          cp "$parpath.menu"   "$menupath/_default.title"
          cp "$parpath.action" "$menupath/_default.action"
        fi
        [ -z "$1" ] && return 1
        local sub="$1" subpath="$menupath/$1"; shift
        if [ ":--remove:" = ":$1:" ]
        then rm -rf "$subpath"*; shift
        else
          [ -z "$2" ] && return 1
          echo "$1" > "$subpath.title"
          echo "$2" > "$subpath.action"
          shift 2
      fi;fi; update=1;;
    set) shift; local suf=.menu
      [ :--action:  = ":$1:" ] && { suf=.action;  shift; }
      [ -z "$1" ] && return 1
      local menu="$1" menupath="$USPLASH/$1"; shift
      if [ :--remove: = ":$1:" ]
      then rm -rf "$menupath"*; shift
      else [ -z "$1" ] && return 1
        echo "$1" > "$menupath$suf"; shift
      fi; update=1;;
  esac

  [ $update -eq 1 ] && { __menu__; return $?; }

  while true
  do _stty raw opost onlret onocr -echo -echonl
    __menu__; _stty $tty
    if [ -f "$USPLASH/action" ]; then
      if ! .  "$USPLASH/action"; then
        rm "$USPLASH/action"
        break; fi
    else break;
    fi;done; }

_usplash_return(){ _usplash_init
  local c="$USPLASH/choice" r= tty=$(_stty -g) CMD=$1; shift
  _stty raw opost onlret onocr -echo -echonl
  _uwk -vHEADLINE="$2" -vVAL="$3" -vCMD=$CMD; r=$?
  [ -f "$USPLASH/choice" ] &&
  export "$1"="$(cat $USPLASH/choice; rm -f $USPLASH/choice)";
  _stty $tty; return $r; }

[ -z "$BUSYBOX" ] && BUSYBOX=$(which busybox)
[ -z "$USPLASH" ] && USPLASH=/run/usplash
[ -z "$UGEAR" ]   && UGEAR=/lib/u/gear
[ -z "$BUSYBOX" ] && { echo REQUIRES: busybox; return 1; }

case "$1" in
init   ) _usplash_init force;                     return 0;;
fini   ) _usplash_fini;                           return 0;;
render ) _usplash_render;                         return 0;;
passwd ) shift; _usplash_passwd "$@";             return $?;;
menu   ) shift; _usplash_menu   "$@";             return $?;;
yesno|choose|select|prompt) _usplash_return "$@"; return $?;;
*) "command not found: $@";                       return 1 ;;
esac; } # skipped first level indentation in the beginning
